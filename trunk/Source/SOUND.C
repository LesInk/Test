/****************************************************************************/
/*    FILE:  SOUND.C                                                        */
/****************************************************************************/

#include "standard.h"

#include "keys.h"         // Include #define's for keyboard commands

#include "sos.h"
#include "sosm.h"
#include "sosez.h"
#include "profile.h"
#include "sosfnct.h"

/* Use the following compile option to output sound lists */
//#ifdef COMPILE_OPTION_SOUND_CHECK_LIST

#define BUFFER_ID_BAD -1
//#define COMPILE_OPTION_OUTPUT_BAD_SOUNDS
#define MUSICVOLUME 192
#define MAX_SOUND_CHANNELS 32

#define FALSE 0
#define TRUE 1

static T_resourceFile G_soundsFile ;
static E_Boolean G_soundsInit = FALSE ;

static E_Boolean G_allowFreqShift = TRUE ;

/* Keep a structure per sound. */
typedef struct {
    T_resource resource ;
    _SOS_SAMPLE sosSample ;
    W32 sosHandle ;
    T_word16 volume ;
    T_soundDoneCallback doneCallback ;
    T_void *doneCallbackData ;
    E_Boolean isAllocated ;
    T_word16 next ;
    T_word16 prev ;
    T_void *p_sample ;
    T_word32 size ;
} T_soundBuffer ;

T_soundBuffer G_soundBufferArray[MAX_SOUND_CHANNELS] ;

/* How many sounds are currently being played? */
static T_word16 G_numSoundsPlaying = 0 ;
static T_word16 G_firstFreeBuffer = 0 ;
static T_word16 G_playingList = BUFFER_ID_BAD ;

/* Volume of sound effects. */
static T_word16 G_soundVolume = 192 ;

/* Volume of background music. */
static T_word16 G_musicVolume = 192 ;

static T_byte8 G_currentSong[20] = "" ;
static T_byte8 G_nextSong[20] = "" ;

/* Background sample being played. */
static      W32  G_backSong = -1 ;

static T_void cdecl ISampleDone(struct _tag_sos_sample *p_sample) ;

/* external variables located in sosez.c */
extern   W32  wDIGIDeviceID;
extern   W32  wMIDIDeviceID;
extern   W32  hDIGIDriver;
extern   W32  hMIDIDriver;

#ifdef COMPILE_OPTION_OUTPUT_BAD_SOUNDS
/* For debugging purposes, output a list of all the bad sounds. */
static FILE *fileBadSounds = NULL ;
#endif

/* Flag to tell if we are doing 16 bit sound. */
static E_Boolean G_is16BitSound = FALSE ;

/* Internal prototypes: */
static T_sword16 IAllocateBuffer(T_resource res) ;

static T_void IFreeBuffer(T_sword16 bufferId) ;

static T_void ISoundStopAtExit(T_void) ;

static T_void ISoundFadeMusic(T_word32 originalVolume) ;

static T_void ISoundFadeInMusic(T_word32 originalVolume) ;

static T_void ISoundStartStreamIO(char *filename) ;

static T_void ICheckForNextMusicUpdate(T_void) ;

#ifdef COMPILE_OPTION_SOUND_CHECK_LIST
static T_void ICheckLists(T_void) ;
#else
#define ICheckLists()
#endif

/* Streamed music information */
#define SIZE_SOUND_STREAM_BUFFER  8192
#define NUM_STREAM_BUFFERS        16
static T_byte8 G_musicBuffer[NUM_STREAM_BUFFERS][SIZE_SOUND_STREAM_BUFFER] ;
static T_word32 G_musicBufferLen[NUM_STREAM_BUFFERS] ;
static T_byte8 G_nextMusicBuffer = 0 ;
static T_byte8 G_nextFillBuffer = 0 ;
static T_file G_musicFile = FILE_BAD ;
static W32 G_musicHandle = 0 ;
static _SOS_SAMPLE G_musicSample ;
static T_word32 G_musicLength = 0 ;
static T_word32 G_musicPos = 0 ;
static E_Boolean G_musicNeedsUpdate = FALSE ;

/****************************************************************************/
/*  Routine:  SoundInitialize                                               */
/****************************************************************************/
/*                                                                          */
/*  Description:                                                            */
/*                                                                          */
/*    SoundInitialize is called to start up the sound system and prepare    */
/*  all interrupts and timers necessary for sound effects and background    */
/*  music.                                                                  */
/*                                                                          */
/*                                                                          */
/*  Problems:                                                               */
/*                                                                          */
/*    None.                                                                 */
/*                                                                          */
/*                                                                          */
/*  Inputs:                                                                 */
/*                                                                          */
/*    None.                                                                 */
/*                                                                          */
/*                                                                          */
/*  Outputs:                                                                */
/*                                                                          */
/*    None.                                                                 */
/*                                                                          */
/*                                                                          */
/*  Revision History:                                                       */
/*                                                                          */
/*    Who  Date:     Comments:                                              */
/*    ---  --------  ---------                                              */
/*    LES  01/19/95  Created                                                */
/*    LES  07/17/96  Changed to handle new T_soundBuffer structures.        */
/*                                                                          */
/****************************************************************************/

T_void SoundInitialize(T_void)
{
    T_word16 i ;
    T_word16 report = 1 ;
    DebugRoutine("SoundInitialize") ;

    if (G_soundsInit == FALSE)  {
        /* Clear out the buffers. */
        memset(G_soundBufferArray, 0, sizeof(G_soundBufferArray)) ;

        /* Link the buffers together into the free buffer. */
        for (i=0; i<MAX_SOUND_CHANNELS; i++)  {
            G_soundBufferArray[i].next = i+1 ;
            G_soundBufferArray[i].prev = i-1 ;
        }
        /* Fix the end points. */
        G_soundBufferArray[0].prev = BUFFER_ID_BAD ;
        G_soundBufferArray[MAX_SOUND_CHANNELS-1].next = BUFFER_ID_BAD ;
        G_firstFreeBuffer = 0 ;
        G_playingList = BUFFER_ID_BAD ;
        ICheckLists() ;

        /* Choose the resource file based on 16 or 8 bit sound. */
        if (G_is16BitSound)  {
            G_soundsFile = ResourceOpen("sounds16.res") ;
        } else {
            G_soundsFile = ResourceOpen("sounds.res") ;
        }

        /* retrieve configuration information from .cfg file */
        if (sosEZGetConfig("hmiset.cfg"))  {
            /* Turn on the sound system. */
            if (!sosEZInitSystem(wDIGIDeviceID, wMIDIDeviceID))
                report = 0 ;
        }
    }

    /* Note if sound is on or off and take appropriate actions. */
    if (report == 0)  {
//        puts("Sound system is ON") ;
	    G_soundsInit = TRUE ;

        /* put in a stopper to keep things from crashing */
        atexit(ISoundStopAtExit) ;
    } else {
        /* No sound system, turn off everything. */
//        puts("Sound system is OFF") ;
        G_soundsInit = FALSE ;
        ResourceClose(G_soundsFile) ;
    }

    fflush(stdout) ;

#ifdef COMPILE_OPTION_OUTPUT_BAD_SOUNDS
    fileBadSounds = fopen("badsound.lst", "a") ;
    fprintf(fileBadSounds, "------------------------------- SESSION\n");
#endif

    DebugEnd() ;
}

/****************************************************************************/
/*  Routine:  SoundFinish                                                   */
/****************************************************************************/
/*                                                                          */
/*  Description:                                                            */
/*                                                                          */
/*    SoundFinish is called before exiting the program.  It turns off all   */
/*  the interrupts and timers that the sound system uses.                   */
/*                                                                          */
/*                                                                          */
/*  Problems:                                                               */
/*                                                                          */
/*    None.                                                                 */
/*                                                                          */
/*                                                                          */
/*  Inputs:                                                                 */
/*                                                                          */
/*    None.                                                                 */
/*                                                                          */
/*                                                                          */
/*  Outputs:                                                                */
/*                                                                          */
/*    None.                                                                 */
/*                                                                          */
/*                                                                          */
/*  Revision History:                                                       */
/*                                                                          */
/*    Who  Date:     Comments:                                              */
/*    ---  --------  ---------                                              */
/*    LES  01/19/95  Created                                                */
/*    LES  01/14/95  Modified to be used by new sound system                */
/*    LES  01/17/96  Modified to turn off all sounds before exiting.        */
/*    LES  07/17/96  Cleaned up and added vector table checks.              */
/*                                                                          */
/****************************************************************************/

T_void SoundFinish(T_void)
{
    DebugRoutine("SoundFinish") ;

    if (G_soundsInit == TRUE)  {
        /* Stop all music */
        SoundStopBackgroundMusic() ;

        /* Stop all the sounds being played. */
        SoundStopAllSounds() ;

        /* Make sure our interrupts are still good before */
        /* we uninstall ours. */
        DebugCheckVectorTable() ;

        /* Turn off the sound system. */
        sosEZUnInitSystem();

        /* Save this change in the vector table. */
        DebugSaveVectorTable() ;

        /* Note that our sound system is disabled. */
        G_soundsInit = FALSE ;

        /* Close the resource file. */
	    ResourceClose(G_soundsFile) ;

#ifdef COMPILE_OPTION_OUTPUT_BAD_SOUNDS
        /* Close out the file to tell we got bad sounds. */
        fclose(fileBadSounds) ;
#endif

    }

//delay(3000) ;

    DebugEnd() ;
}

/****************************************************************************/
/*  Routine:  SoundSetBackgroundMusic                                       */
/****************************************************************************/
/*                                                                          */
/*  Description:                                                            */
/*                                                                          */
/*    SoundSetBackgroundMusic loads and plays a background song.            */
/*                                                                          */
/*                                                                          */
/*  Problems:                                                               */
/*                                                                          */
/*    At this point, I don't know what happens when you call this routine   */
/*  while a song is already in progress.                                    */
/*                                                                          */
/*                                                                          */
/*  Inputs:                                                                 */
/*                                                                          */
/*    T_byte8 *filename           -- Name of background song to play.       */
/*                                                                          */
/*                                                                          */
/*  Outputs:                                                                */
/*                                                                          */
/*    None.                                                                 */
/*                                                                          */
/*                                                                          */
/*  Revision History:                                                       */
/*                                                                          */
/*    Who  Date:     Comments:                                              */
/*    ---  --------  ---------                                              */
/*    LES  01/19/95  Created                                                */
/*    LES  05/08/95  Modified to load and play music only if sound init.    */
/*    LES  07/26/95  Modified to check if song is already being played.     */
/*    LES  07/17/96  Use G_songIsPlaying instead of G_modplaying var.       */
/*                                                                          */
/****************************************************************************/

T_void SoundSetBackgroundMusic(T_byte8 *filename)
{
    W32 newSong;
    char realFilename[80] ;
	DebugRoutine("SoundSetBackgroundMusic") ;

    if (SoundIsOn())  {
        /* See if we are already playing this one. */
        if (strcmp(filename, G_currentSong) != 0)  {
            /* Record as this song. */
            strcpy(G_currentSong, filename) ;

            /* Stop whatever sound is currently playing. */
            SoundStopBackgroundMusic() ;

            if (G_musicVolume != 0)  {
                switch (ConfigGetMusicType()) {
                    case MUSIC_TYPE_MIDI:
                        sprintf(realFilename, "%s.HMI", filename) ;
                        if ((newSong = sosEZLoadSong(realFilename)) != -1)  {
                            G_backSong = newSong ;

                            /* start playing the song. */
                            sosMIDIStartSong(G_backSong);
                        } else {
#                           ifndef NDEBUG
                            printf("Could not play song %s\n", filename) ;
#                           endif
                        }

    //                    SoundSetBackgroundVolume(G_musicVolume) ;
                        break;

                    case MUSIC_TYPE_STREAM_IO:
                        ISoundStartStreamIO(filename) ;
    //                    SoundSetBackgroundVolume(G_musicVolume) ;
                        break ;

                    case MUSIC_TYPE_NONE:
                    default:
                        break ;
                }
            }
        }
    }

    DebugEnd() ;
}

/****************************************************************************/
/*  Routine:  SoundPlayByName                                               */
/****************************************************************************/
/*                                                                          */
/*  Description:                                                            */
/*                                                                          */
/*    SoundPlayByName looks up a sound in the sound file, if not loaded--   */
/*  loads it in, and plays that sound.  Finally, the sound is unlocked      */
/*  for possible removal.                                                   */
/*                                                                          */
/*                                                                          */
/*  Problems:                                                               */
/*                                                                          */
/*    None.                                                                 */
/*                                                                          */
/*                                                                          */
/*  Inputs:                                                                 */
/*                                                                          */
/*    T_byte8 *filename           -- Name of sound to play                  */
/*                                                                          */
/*                                                                          */
/*  Outputs:                                                                */
/*                                                                          */
/*    T_sword16                   -- Channel number of sound, or -1 if none.*/
/*                                                                          */
/*                                                                          */
/*  Calls:                                                                  */
/*                                                                          */
/*    ResourceFind                                                          */
/*    ResourceLock                                                          */
/*    ResourceGetSize                                                       */
/*    TriggerSound                                                          */
/*                                                                          */
/*                                                                          */
/*  Revision History:                                                       */
/*                                                                          */
/*    Who  Date:     Comments:                                              */
/*    ---  --------  ---------                                              */
/*    LES  01/19/95  Created                                                */
/*    LES  04/26/95  Modified to return channel number                      */
/*    LES  07/17/96  Changed to use G_soundBufferArray                      */
/*                                                                          */
/****************************************************************************/

T_sword16 SoundPlayByName(T_byte8 *filename, T_word16 volume)
{
    T_resource sound ;
    T_word32 newVolume ;
    _SOS_SAMPLE *p_sample ;
    W32 hSample;
    T_sword16 bufferId = BUFFER_ID_BAD ;
    T_soundBuffer *p_buffer ;

    DebugRoutine("PlaySoundByName") ;

    if (G_soundsInit == TRUE)  {
        sound = ResourceFind(G_soundsFile, filename) ;
        if (sound != RESOURCE_BAD)  {
            bufferId = IAllocateBuffer(sound) ;
            if (bufferId != BUFFER_ID_BAD)  {
                DebugCheck(bufferId < MAX_SOUND_CHANNELS) ;
                DebugCheck(bufferId >= 0) ;
                p_buffer= G_soundBufferArray + bufferId ;
                p_sample = &p_buffer->sosSample ;
                DebugCheck(p_sample != NULL) ;

                memset(p_sample, 0, sizeof(_SOS_SAMPLE)) ;
                p_sample->pSample = p_buffer->p_sample ;
                p_sample->wLength = p_buffer->size ;

                if (G_is16BitSound)  {
                    p_sample->wBitsPerSample = 0x10 ;
                    p_sample->wChannels = 1 ;
                    if (G_allowFreqShift)
                        p_sample->wRate = 22050 + (rand() & 2047) - 1000 ;
                    else
                        p_sample->wRate = 22050 ;
//                        p_sample->wFormat = _PCM_UNSIGNED ;
                    p_sample->wFormat = 0 ;
                } else {
                    p_sample->wBitsPerSample = 0x08 ;
                    p_sample->wChannels = 1 ;
                    if (G_allowFreqShift)
                        p_sample->wRate = 11000 + (rand() & 1023) - 500 ;
                    else
                        p_sample->wRate = 11000 ;

                    p_sample->wFormat = _PCM_UNSIGNED ;
                }

                p_sample->wPanPosition = _PAN_CENTER ;
                newVolume = volume ;
                newVolume *= G_soundVolume ;
                newVolume >>= 1 ;
                p_sample->wVolume = MK_VOLUME(newVolume, newVolume) ;

                hSample = sosDIGIStartSample(hDIGIDriver, p_sample) ;

                /* Did we get a sound to play? */
                if (hSample != _ERR_NO_SLOTS)  {
                    /* The sound is being played.  */
                    /* Note what resource and sound */
                    /* this is. */
                    DebugCheck(hSample < MAX_SOUND_CHANNELS) ;
                    p_buffer->sosHandle = hSample ;
                    p_buffer->volume = volume ;
                    p_buffer->doneCallback = NULL ;
                } else {
                    /* No sound.  Let the buffer go. */
                    IFreeBuffer(bufferId) ;
                    bufferId = BUFFER_ID_BAD ;
                }
            }
        } else {
#ifdef COMPILE_OPTION_OUTPUT_BAD_SOUNDS
            fprintf(fileBadSounds, "sound '%s' not found\n", filename) ;  fflush(fileBadSounds) ;
            MessagePrintf("sound '%s' not found\n", filename) ;  fflush(fileBadSounds) ;
#endif
        }

    }

    DebugEnd() ;

    return bufferId ;
}

/****************************************************************************/
/*  Routine:  SoundPlayLoopByNumber                                         */
/****************************************************************************/
/*                                                                          */
/*  Description:                                                            */
/*                                                                          */
/*    SoundPlayLoopByNumber works just like SoundPlayByNumber except that   */
/*  it loops the sound being played until it is stopped.                    */
/*                                                                          */
/*                                                                          */
/*  Problems:                                                               */
/*                                                                          */
/*    None.                                                                 */
/*                                                                          */
/*                                                                          */
/*  Inputs:                                                                 */
/*                                                                          */
/*    T_word16 soundNum           -- Number of sound to play                */
/*                                                                          */
/*    T_word16 volume             -- Volume level to play sound             */
/*                                                                          */
/*                                                                          */
/*  Outputs:                                                                */
/*                                                                          */
/*    T_sword16                   -- Channel number of sound, or -1 if none.*/
/*                                                                          */
/*                                                                          */
/*  Calls:                                                                  */
/*                                                                          */
/*    ResourceFind                                                          */
/*    ResourceLock                                                          */
/*    ResourceGetSize                                                       */
/*    TriggerSound                                                          */
/*                                                                          */
/*                                                                          */
/*  Revision History:                                                       */
/*                                                                          */
/*    Who  Date:     Comments:                                              */
/*    ---  --------  ---------                                              */
/*    LES  04/28/95  Created                                                */
/*    LES  05/08/95  Modified to keep sounds in memory until fully played.  */
/*    LES  07/17/96  Changed to use G_soundBufferArray                      */
/*                                                                          */
/****************************************************************************/

T_sword16 SoundPlayLoopByNumber(T_word16 soundNum, T_word16 volume)
{
    T_resource sound ;
    T_word32 newVolume ;
    _SOS_SAMPLE *p_sample ;
    W32 hSample;
    T_sword16 bufferId = BUFFER_ID_BAD ;
    T_soundBuffer *p_buffer ;
    T_byte8 filename[20] ;

    DebugRoutine("SoundPlayLoopByNumber") ;
    if (G_soundsInit == TRUE)  {
	    sprintf(filename, "snd#%d", soundNum) ;
        sound = ResourceFind(G_soundsFile, filename) ;
        if (sound != RESOURCE_BAD)  {
            bufferId = IAllocateBuffer(sound) ;
            if (bufferId != BUFFER_ID_BAD)  {
                DebugCheck(bufferId < MAX_SOUND_CHANNELS) ;
                DebugCheck(bufferId >= 0) ;
                p_buffer= G_soundBufferArray + bufferId ;
                p_sample = &p_buffer->sosSample ;
                DebugCheck(p_sample != NULL) ;

                memset(p_sample, 0, sizeof(_SOS_SAMPLE)) ;
                p_sample->pSample = p_buffer->p_sample ;
                p_sample->wLength = p_buffer->size ;

                if (G_is16BitSound)  {
                    p_sample->wBitsPerSample = 0x10 ;
                    p_sample->wChannels = 1 ;
                    if (G_allowFreqShift)
                        p_sample->wRate = 22050 + (rand() & 2047) - 1000 ;
                    else
                        p_sample->wRate = 22050 ;
//                        p_sample->wFormat = _PCM_UNSIGNED ;
                    p_sample->wFormat = 0 ;
                } else {
                    p_sample->wBitsPerSample = 0x08 ;
                    p_sample->wChannels = 1 ;
                    if (G_allowFreqShift)
                        p_sample->wRate = 11000 + (rand() & 1023) - 500 ;
                    else
                        p_sample->wRate = 11000 ;
                    p_sample->wFormat = _PCM_UNSIGNED ;
                }

                p_sample->wPanPosition = _PAN_CENTER ;
                newVolume = volume ;
                newVolume *= G_soundVolume ;
                newVolume >>= 1 ;
                p_sample->wVolume = MK_VOLUME(newVolume, newVolume) ;

                /* Make the sound loop. */
                p_sample->wLoopLength = p_buffer->size ;
                p_sample->wLoopEndLength = 0 ;
                p_sample->wLoopStage = 0 ;
                p_sample->wLoopCount = 0x7FFFFFFF ;

                /* Start playing the sample. */
                hSample = sosDIGIStartSample(hDIGIDriver, p_sample) ;

                /* Did we get a sound to play? */
                if (hSample != _ERR_NO_SLOTS)  {
                    /* The sound is being played.  */
                    /* Note what resource and sound */
                    /* this is. */
                    DebugCheck(hSample < MAX_SOUND_CHANNELS) ;
                    p_buffer->sosHandle = hSample ;
                    p_buffer->volume = volume ;
                    p_buffer->doneCallback = NULL ;
                } else {
                    /* No sound.  Let the buffer go. */
                    IFreeBuffer(bufferId) ;
                    bufferId = BUFFER_ID_BAD ;
                }
            }
        } else {
#ifdef COMPILE_OPTION_OUTPUT_BAD_SOUNDS
            fprintf(fileBadSounds, "sound '%s' not found\n", filename) ;  fflush(fileBadSounds) ;
            MessagePrintf("sound '%s' not found\n", filename) ;  fflush(fileBadSounds) ;
#endif
        }
    }

    DebugEnd() ;

    return bufferId ;
}

/****************************************************************************/
/*  Routine:  SoundPlayByNumber                                             */
/****************************************************************************/
/*                                                                          */
/*  Description:                                                            */
/*                                                                          */
/*    SoundPlayByNumber looks up the sound to be played by its number.      */
/*  In actuallity, it looks for the name snd#??? where ??? is the number    */
/*  to be played.  Once found, the digital sound is played.                 */
/*                                                                          */
/*                                                                          */
/*  Problems:                                                               */
/*                                                                          */
/*    None.                                                                 */
/*                                                                          */
/*                                                                          */
/*  Inputs:                                                                 */
/*                                                                          */
/*    T_word16 num                -- #0-65535 of the sound to play          */
/*                                                                          */
/*    T_word16 volume             -- Volume level to play sound             */
/*                                                                          */
/*                                                                          */
/*  Outputs:                                                                */
/*                                                                          */
/*    T_sword16                   -- Channel number of sound, or -1 if none.*/
/*                                                                          */
/*                                                                          */
/*  Calls:                                                                  */
/*                                                                          */
/*    SoundPlayByName                                                       */
/*                                                                          */
/*                                                                          */
/*  Revision History:                                                       */
/*                                                                          */
/*    Who  Date:     Comments:                                              */
/*    ---  --------  ---------                                              */
/*    LES  01/19/95  Created                                                */
/*    LES  04/26/95  Modified to return channel number                      */
/*                                                                          */
/****************************************************************************/

T_sword16 SoundPlayByNumber(T_word16 num, T_word16 volume)
{
    char buffer[20] ;
    T_sword16 bufferId = BUFFER_ID_BAD ;

    DebugRoutine("PlaySoundByNumber") ;

    /* Don't play any sound unless the sound system was initialized. */
    if (G_soundsInit == TRUE)  {
	    sprintf(buffer, "snd#%d", (T_word32)num) ;
	    bufferId = SoundPlayByName(buffer, volume) ;
    }

    DebugEnd() ;

    return bufferId ;
}

/****************************************************************************/
/*  Routine:                                                                */
/****************************************************************************/
/*                                                                          */
/*  Description:                                                            */
/*                                                                          */
/*    SoundIsOn checks to see if the sound system is enabled and returns    */
/*  this fact.                                                              */
/*                                                                          */
/*                                                                          */
/*  Problems:                                                               */
/*                                                                          */
/*    None.                                                                 */
/*                                                                          */
/*                                                                          */
/*  Inputs:                                                                 */
/*                                                                          */
/*    None.                                                                 */
/*                                                                          */
/*                                                                          */
/*  Outputs:                                                                */
/*                                                                          */
/*    E_Boolean                   -- TRUE if sound is enabled, FALSE if not */
/*                                                                          */
/*                                                                          */
/*  Calls:                                                                  */
/*                                                                          */
/*    Nothing.                                                              */
/*                                                                          */
/*                                                                          */
/*  Revision History:                                                       */
/*                                                                          */
/*    Who  Date:     Comments:                                              */
/*    ---  --------  ---------                                              */
/*    LES  01/19/95  Created                                                */
/*                                                                          */
/****************************************************************************/

E_Boolean SoundIsOn(T_void)
{
    E_Boolean ret ;
    DebugRoutine("SoundIsOn") ;

    ret = G_soundsInit ;

    DebugCheck(ret < BOOLEAN_UNKNOWN) ;
    DebugEnd() ;

    return ret ;
}

/****************************************************************************/
/*  Routine:  SoundSetBackgroundVolume                                      */
/****************************************************************************/
/*                                                                          */
/*  Description:                                                            */
/*                                                                          */
/*    SoundSetBackgroundVolume changes the volume that the current or       */
/*  soon to be played background music is at.                               */
/*                                                                          */
/*                                                                          */
/*  Problems:                                                               */
/*                                                                          */
/*    None.                                                                 */
/*                                                                          */
/*                                                                          */
/*  Inputs:                                                                 */
/*                                                                          */
/*    T_byte8 volume              -- Volume level (0-255)                   */
/*                                                                          */
/*                                                                          */
/*  Outputs:                                                                */
/*                                                                          */
/*    None.                                                                 */
/*                                                                          */
/*                                                                          */
/*  Calls:                                                                  */
/*                                                                          */
/*    MODSetMusicVolume                                                     */
/*                                                                          */
/*                                                                          */
/*  Revision History:                                                       */
/*                                                                          */
/*    Who  Date:     Comments:                                              */
/*    ---  --------  ---------                                              */
/*    LES  01/19/95  Created                                                */
/*                                                                          */
/****************************************************************************/

T_void SoundSetBackgroundVolume(T_byte8 volume)
{
    T_word32 vol ;
    T_byte8 oldVol ;
    char filename[80] ;

    DebugRoutine("SoundSetBackgroundVolume") ;

    oldVol = G_musicVolume ;
    if (G_soundsInit)  {
        /* Just turn off the music */
        if (volume == 0)  {
            G_musicVolume = 0 ;
            SoundStopBackgroundMusic() ;
        } else {
            oldVol = G_musicVolume ;

            G_musicVolume = volume ;
            vol = volume ;
            vol <<= 7 ;

            /* Music was off ... start it up */
            if ((oldVol == 0) && (volume != 0))  {
                strcpy(filename, G_currentSong) ;
                G_currentSong[0] = '\0' ;
                SoundSetBackgroundMusic(filename) ;
            }

            sosMIDISetMasterVolume(volume) ;

            if (G_musicFile != FILE_BAD)  {
                sosDIGISetSampleVolume(
                    hDIGIDriver,
                    G_musicHandle,
                    MK_VOLUME(vol, vol)) ;
            }
        }
    }


    DebugEnd() ;
}

T_byte8 SoundGetBackgroundVolume(T_void)
{
    return G_musicVolume ;
}

/****************************************************************************/
/*  Routine:  SoundSetEffectsVolume                                         */
/****************************************************************************/
/*                                                                          */
/*  Description:                                                            */
/*                                                                          */
/*    SoundSetEffectsVolume sets the volume of the sound effects.           */
/*                                                                          */
/*                                                                          */
/*  Problems:                                                               */
/*                                                                          */
/*    None.                                                                 */
/*                                                                          */
/*                                                                          */
/*  Inputs:                                                                 */
/*                                                                          */
/*    T_word16 volume             -- Level of sound                         */
/*                                                                          */
/*                                                                          */
/*  Outputs:                                                                */
/*                                                                          */
/*    None.                                                                 */
/*                                                                          */
/*                                                                          */
/*  Calls:                                                                  */
/*                                                                          */
/*    Nothing.                                                              */
/*                                                                          */
/*                                                                          */
/*  Revision History:                                                       */
/*                                                                          */
/*    Who  Date:     Comments:                                              */
/*    ---  --------  ---------                                              */
/*    LES  07/25/95  Created                                                */
/*    LES  07/17/96  Modified to handle G_soundBufferArray                  */
/*                                                                          */
/****************************************************************************/

T_void SoundSetEffectsVolume(T_word16 volume)
{
    T_word16 i ;
    T_word16 vol ;
    T_sword16 bufferId ;
    T_soundBuffer *p_buffer ;

    DebugRoutine("SoundSetEffectsVolume") ;
    DebugCheck(volume < 256) ;

    G_soundVolume = volume ;

    /* Go through the list of all playing sounds and modify */
    /* their volume. */
    bufferId = G_playingList ;
    while (bufferId != BUFFER_ID_BAD)  {
        DebugCheck(bufferId >= 0) ;
        DebugCheck(bufferId < MAX_SOUND_CHANNELS) ;
        p_buffer = G_soundBufferArray + bufferId ;

        vol = (p_buffer->volume * volume) >> 1 ;
        sosDIGISetSampleVolume(
            hDIGIDriver,
            p_buffer->sosHandle,
            vol) ;
        p_buffer->volume = vol>>7 ;

        bufferId = p_buffer->next ;
    }

    DebugEnd() ;
}

/****************************************************************************/
/*  Routine:  SoundGetEffectsVolume                                         */
/****************************************************************************/
/*                                                                          */
/*  Description:                                                            */
/*                                                                          */
/*    SoundGetEffectsVolume gets the volume of the sound effects.           */
/*                                                                          */
/*                                                                          */
/*  Problems:                                                               */
/*                                                                          */
/*    None.                                                                 */
/*                                                                          */
/*                                                                          */
/*  Inputs:                                                                 */
/*                                                                          */
/*    None.                                                                 */
/*                                                                          */
/*                                                                          */
/*  Outputs:                                                                */
/*                                                                          */
/*    T_word16 volume             -- Level of sound                         */
/*                                                                          */
/*                                                                          */
/*  Revision History:                                                       */
/*                                                                          */
/*    Who  Date:     Comments:                                              */
/*    ---  --------  ---------                                              */
/*    LES  07/25/95  Created                                                */
/*                                                                          */
/****************************************************************************/

T_word16 SoundGetEffectsVolume(T_void)
{
    T_word16 volume ;

    DebugRoutine("SoundGetEffectsVolume") ;

    volume = G_soundVolume ;

    DebugCheck(volume < 256) ;
    DebugEnd() ;

    return volume ;
}

/****************************************************************************/
/*  Routine:  ISoundStopAtExit                                              */
/****************************************************************************/
/*                                                                          */
/*  Description:                                                            */
/*                                                                          */
/*    ISoundStopAtExit is a callback routine for the atexit command that    */
/*  turns off the sound system.                                             */
/*                                                                          */
/*                                                                          */
/*  Problems:                                                               */
/*                                                                          */
/*    None.                                                                 */
/*                                                                          */
/*                                                                          */
/*  Inputs:                                                                 */
/*                                                                          */
/*    None.                                                                 */
/*                                                                          */
/*                                                                          */
/*  Outputs:                                                                */
/*                                                                          */
/*    None.                                                                 */
/*                                                                          */
/*                                                                          */
/*  Revision History:                                                       */
/*                                                                          */
/*    Who  Date:     Comments:                                              */
/*    ---  --------  ---------                                              */
/*    LES  07/25/95  Created                                                */
/*                                                                          */
/****************************************************************************/

T_void ISoundStopAtExit(T_void)
{
#ifndef NDEBUG
//    puts("Restoring sound system.") ;
#endif
    SoundFinish() ;
}

/****************************************************************************/
/*  Routine:  SoundUpdate                                                   */
/****************************************************************************/
/*                                                                          */
/*  Description:                                                            */
/*                                                                          */
/*    SoundUpdate should be called as often as possible to ensure the       */
/*  resource manager locks and unlocks all the data tied to the             */
/*  sound effects.                                                          */
/*                                                                          */
/*                                                                          */
/*  Problems:                                                               */
/*                                                                          */
/*    None.                                                                 */
/*                                                                          */
/*                                                                          */
/*  Inputs:                                                                 */
/*                                                                          */
/*    None.                                                                 */
/*                                                                          */
/*                                                                          */
/*  Outputs:                                                                */
/*                                                                          */
/*    None.                                                                 */
/*                                                                          */
/*                                                                          */
/*  Revision History:                                                       */
/*                                                                          */
/*    Who  Date:     Comments:                                              */
/*    ---  --------  ---------                                              */
/*    LES  01/17/95  Created                                                */
/*    LES  04/29/96  Added code to unlock sound resources in queue          */
/*                                                                          */
/****************************************************************************/

T_void SoundUpdate(T_void)
{
    T_sword16 bufferId ;
    T_soundBuffer *p_buffer ;
    T_sword16 nextId ;

    DebugRoutine("SoundUpdate") ;

//MessagePrintf("num sounds %d\n", G_numSoundsPlaying) ;
    if (SoundIsOn())  {
        /* Check for a completed music score. */
        if (G_backSong != -1)  {
            /* Repeat the song if it is finished. */
            if (sosMIDISongDone(G_backSong))  {
                /* start song */
                sosMIDIStartSong(G_backSong);
            }
        }

        /* Free all buffers that are complete. */
        bufferId = G_playingList ;
        while (bufferId != BUFFER_ID_BAD)  {
            DebugCheck(bufferId >= 0) ;
            DebugCheck(bufferId < MAX_SOUND_CHANNELS) ;
            p_buffer = G_soundBufferArray + bufferId ;
            nextId = p_buffer->next ;
            /* See if any sounds are done. */
            if (sosDIGISampleDone(hDIGIDriver, p_buffer->sosHandle))  {
                /* Do the callback first, then free. */
                if (p_buffer->doneCallback != NULL)  {
                    /* call the done callback reporting the */
                    /* sound complete. */
                    p_buffer->doneCallback(p_buffer->doneCallbackData) ;
                    p_buffer->doneCallback = NULL ;
                }
                /* If so, close out the buffer. */
                IFreeBuffer(bufferId) ;
            }
            bufferId = nextId ;
        }
    }

    DebugEnd() ;
}

/****************************************************************************/
/*  Routine:  SoundStopAllSounds                                            */
/****************************************************************************/
/*                                                                          */
/*  Description:                                                            */
/*                                                                          */
/*    SoundStopAllSounds turns off all the sounds being played in digital   */
/*  form.  The music is not affected.                                       */
/*                                                                          */
/*                                                                          */
/*  Problems:                                                               */
/*                                                                          */
/*    None.                                                                 */
/*                                                                          */
/*                                                                          */
/*  Inputs:                                                                 */
/*                                                                          */
/*    None.                                                                 */
/*                                                                          */
/*                                                                          */
/*  Outputs:                                                                */
/*                                                                          */
/*    None.                                                                 */
/*                                                                          */
/*                                                                          */
/*  Calls:                                                                  */
/*                                                                          */
/*    sosDIGIStopSample                                                     */
/*    SoundUpdate                                                           */
/*                                                                          */
/*                                                                          */
/*  Revision History:                                                       */
/*                                                                          */
/*    Who  Date:     Comments:                                              */
/*    ---  --------  ---------                                              */
/*    LES  01/17/95  Created                                                */
/*                                                                          */
/****************************************************************************/

T_void SoundStopAllSounds(T_void)
{
    T_sword16 bufferId ;
    T_soundBuffer *p_buffer ;

    DebugRoutine("SoundStopAllSounds") ;

    if (SoundIsOn())  {
        /* Free all buffers that are complete. */
        bufferId = G_playingList ;
        while (bufferId != BUFFER_ID_BAD)  {
            DebugCheck(bufferId >= 0) ;
            DebugCheck(bufferId < MAX_SOUND_CHANNELS) ;
            p_buffer = G_soundBufferArray + bufferId ;
            SoundStop(bufferId) ;
            bufferId = p_buffer->next ;
        }
    }

    /* Update the resource manager to tell */
    /* that the sounds are now freed. */
    SoundUpdate() ;

    DebugEnd() ;
}

/****************************************************************************/
/*  Routine:  SoundIsDone                                                   */
/****************************************************************************/
/*                                                                          */
/*  Description:                                                            */
/*                                                                          */
/*    SoundIsDone checks to see if the given sound is turned off.           */
/*                                                                          */
/*                                                                          */
/*  Problems:                                                               */
/*                                                                          */
/*    None.                                                                 */
/*                                                                          */
/*                                                                          */
/*  Inputs:                                                                 */
/*                                                                          */
/*    T_sword16 bufferId           -- Channel/handle of previous sound.      */
/*                                                                          */
/*                                                                          */
/*  Outputs:                                                                */
/*                                                                          */
/*    None.                                                                 */
/*                                                                          */
/*                                                                          */
/*  Calls:                                                                  */
/*                                                                          */
/*    Nothing                                                               */
/*                                                                          */
/*                                                                          */
/*  Revision History:                                                       */
/*                                                                          */
/*    Who  Date:     Comments:                                              */
/*    ---  --------  ---------                                              */
/*    LES  01/17/95  Created                                                */
/*                                                                          */
/****************************************************************************/

E_Boolean SoundIsDone(T_sword16 bufferId)
{
    E_Boolean isDone ;
    T_soundBuffer *p_buffer ;

    DebugRoutine("SoundIsDone") ;
    DebugCheck(bufferId != BUFFER_ID_BAD) ;
    DebugCheck(bufferId >= 0) ;
    DebugCheck(bufferId < MAX_SOUND_CHANNELS) ;

    /* Get a buffer entry. */
    p_buffer = G_soundBufferArray + bufferId ;
    DebugCheck(p_buffer->isAllocated == TRUE) ;

    if (sosDIGISampleDone(hDIGIDriver, p_buffer->sosHandle))  {
        isDone = FALSE ;
    } else {
        isDone = TRUE ;
    }

    DebugEnd() ;

    return isDone ;
}

/****************************************************************************/
/*  Routine:  SoundSetVolume                                                */
/****************************************************************************/
/*                                                                          */
/*  Description:                                                            */
/*                                                                          */
/*    SoundSetVolume changes the volume of a current sound effect.          */
/*                                                                          */
/*                                                                          */
/*  Problems:                                                               */
/*                                                                          */
/*    None.                                                                 */
/*                                                                          */
/*                                                                          */
/*  Inputs:                                                                 */
/*                                                                          */
/*    T_sword16 bufferId           -- Channel/handle of previous sound.      */
/*                                                                          */
/*    T_word16 volume             -- Volume of 0-255 to change to.          */
/*                                                                          */
/*                                                                          */
/*  Outputs:                                                                */
/*                                                                          */
/*    None.                                                                 */
/*                                                                          */
/*                                                                          */
/*  Calls:                                                                  */
/*                                                                          */
/*    Nothing                                                               */
/*                                                                          */
/*                                                                          */
/*  Revision History:                                                       */
/*                                                                          */
/*    Who  Date:     Comments:                                              */
/*    ---  --------  ---------                                              */
/*    LES  01/17/95  Created                                                */
/*                                                                          */
/****************************************************************************/

T_void SoundSetVolume(T_sword16 bufferId, T_word16 volume)
{
    T_soundBuffer *p_buffer ;

    DebugRoutine("SoundSetVolume") ;

    if (SoundIsOn())  {
        DebugCheck(bufferId != BUFFER_ID_BAD) ;
        DebugCheck(bufferId >= 0) ;
        DebugCheck(bufferId < MAX_SOUND_CHANNELS) ;

        /* Get a buffer entry. */
        p_buffer = G_soundBufferArray + bufferId ;
        DebugCheck(p_buffer->isAllocated == TRUE) ;

        sosDIGISetSampleVolume(
            hDIGIDriver,
            p_buffer->sosHandle,
            (volume<<8)) ;
    }

    DebugEnd() ;
}

/****************************************************************************/
/*  Routine:  SoundSetStereoPanLocation                                     */
/****************************************************************************/
/*                                                                          */
/*  Description:                                                            */
/*                                                                          */
/*    SoundSetStereoPanLocation changes the stereo panning on a given       */
/*  sound effect.                                                           */
/*                                                                          */
/*                                                                          */
/*  Problems:                                                               */
/*                                                                          */
/*    None.                                                                 */
/*                                                                          */
/*                                                                          */
/*  Inputs:                                                                 */
/*                                                                          */
/*    T_sword16 bufferId           -- Channel/handle of previous sound.      */
/*                                                                          */
/*    T_word16 panLocation        -- Pan is 0 if all on left, 0x8000 if     */
/*                                   centered, and 0xFFFF if all on right.  */
/*                                                                          */
/*                                                                          */
/*  Outputs:                                                                */
/*                                                                          */
/*    None.                                                                 */
/*                                                                          */
/*                                                                          */
/*  Calls:                                                                  */
/*                                                                          */
/*    sosDIGISetPanLocation                                                 */
/*                                                                          */
/*                                                                          */
/*  Revision History:                                                       */
/*                                                                          */
/*    Who  Date:     Comments:                                              */
/*    ---  --------  ---------                                              */
/*    LES  01/18/95  Created                                                */
/*                                                                          */
/****************************************************************************/

T_void SoundSetStereoPanLocation(T_sword16 bufferId, T_word16 panLocation)
{
    T_soundBuffer *p_buffer ;

    DebugRoutine("SoundSetStereoPanLocation") ;

    if (SoundIsOn())  {
        DebugCheck(bufferId != BUFFER_ID_BAD) ;
        DebugCheck(bufferId >= 0) ;
        DebugCheck(bufferId < MAX_SOUND_CHANNELS) ;

        /* Get a buffer entry. */
        p_buffer = G_soundBufferArray + bufferId ;
        DebugCheck(p_buffer->isAllocated == TRUE) ;

        sosDIGISetPanLocation(
            hDIGIDriver,
            p_buffer->sosHandle,
            panLocation) ;
    }

    DebugEnd() ;
}

/* LES: 04/08/96 */
T_sword16 SoundPlayByNumberWithCallback(
              T_word16 num,
              T_word16 volume,
              T_soundDoneCallback callback,
              T_void *p_data)
{
    T_soundBuffer *p_buffer ;
    T_sword16 bufferId ;

    DebugRoutine("SoundPlayByNumberWithCallback") ;

    bufferId = SoundPlayByNumber(num, volume) ;
    if (bufferId != BUFFER_ID_BAD)  {
        DebugCheck(bufferId != BUFFER_ID_BAD) ;
        DebugCheck(bufferId >= 0) ;
        DebugCheck(bufferId < MAX_SOUND_CHANNELS) ;

        p_buffer = G_soundBufferArray + bufferId ;
        DebugCheck(p_buffer->isAllocated == TRUE) ;

        p_buffer->doneCallback = callback ;
        p_buffer->doneCallbackData = p_data ;
    }

    DebugEnd() ;

    return bufferId ;
}

/* LES: 04/08/96 */
T_sword16 SoundPlayLoopByNumberWithCallback(
              T_word16 num,
              T_word16 volume,
              T_soundDoneCallback callback,
              T_void *p_data)
{
    T_soundBuffer *p_buffer ;
    T_sword16 bufferId ;

    DebugRoutine("SoundPlayLoopByNumberWithCallback") ;

    bufferId = SoundPlayLoopByNumber(num, volume) ;
    if (bufferId != BUFFER_ID_BAD)  {
        DebugCheck(bufferId != BUFFER_ID_BAD) ;
        DebugCheck(bufferId >= 0) ;
        DebugCheck(bufferId < MAX_SOUND_CHANNELS) ;

        p_buffer = G_soundBufferArray + bufferId ;
        DebugCheck(p_buffer->isAllocated == TRUE) ;

        p_buffer->doneCallback = callback ;
        p_buffer->doneCallbackData = p_data ;
    }

    DebugEnd() ;

    return bufferId ;
}

/****************************************************************************/
/*  Routine:  IAllocateBuffer                         * INTERNAL *          */
/****************************************************************************/
/*                                                                          */
/*  Description:                                                            */
/*                                                                          */
/*    IAllocateBuffer quickly finds a free sound buffer and returns it.     */
/*                                                                          */
/*                                                                          */
/*  Inputs:                                                                 */
/*                                                                          */
/*    None.                                                                 */
/*                                                                          */
/*                                                                          */
/*  Outputs:                                                                */
/*                                                                          */
/*    T_sword16                   -- index to buffer, or -1 for none.       */
/*                                                                          */
/*                                                                          */
/*  Revision History:                                                       */
/*                                                                          */
/*    Who  Date:     Comments:                                              */
/*    ---  --------  ---------                                              */
/*    LES  07/17/96  Created                                                */
/*                                                                          */
/****************************************************************************/

static T_sword16 IAllocateBuffer(T_resource res)
{
    T_sword16 bufferId ;
    T_soundBuffer *p_buffer ;

    DebugRoutine("IAllocateBuffer") ;
    /* Pull one off the front. */
    bufferId = G_firstFreeBuffer ;

    /* Is there any? */
    if (bufferId != BUFFER_ID_BAD)  {
        DebugCheck(bufferId >= 0) ;
        DebugCheck(bufferId < MAX_SOUND_CHANNELS) ;

        /* Fix up the next free buffer. */
        p_buffer = G_soundBufferArray + bufferId ;
        DebugCheck(p_buffer->isAllocated == FALSE) ;
        G_firstFreeBuffer = p_buffer->next ;
        if (G_firstFreeBuffer != BUFFER_ID_BAD)
            G_soundBufferArray[G_firstFreeBuffer].prev = BUFFER_ID_BAD ;

        /* Put the new item on the play list. */
        p_buffer->next = G_playingList ;
        p_buffer->prev = BUFFER_ID_BAD ;
        if (G_playingList != BUFFER_ID_BAD)
            G_soundBufferArray[G_playingList].prev = bufferId ;
        G_playingList = bufferId ;

        p_buffer->resource = res ;
        p_buffer->p_sample = ResourceLock(res) ;
        p_buffer->size = ResourceGetSize(res) ;

        G_numSoundsPlaying++ ;
        p_buffer->isAllocated = TRUE ;

        ICheckLists() ;
    }

    DebugEnd() ;

    return bufferId ;
}

/****************************************************************************/
/*  Routine:  IFreeBuffer                             * INTERNAL *          */
/****************************************************************************/
/*                                                                          */
/*  Description:                                                            */
/*                                                                          */
/*    IFreeBuffer quickly frees a previously allocated buffer.              */
/*                                                                          */
/*                                                                          */
/*  Inputs:                                                                 */
/*                                                                          */
/*    None.                                                                 */
/*                                                                          */
/*                                                                          */
/*  Outputs:                                                                */
/*                                                                          */
/*    T_sword16                   -- index to buffer, or -1 for none.       */
/*                                                                          */
/*                                                                          */
/*  Revision History:                                                       */
/*                                                                          */
/*    Who  Date:     Comments:                                              */
/*    ---  --------  ---------                                              */
/*    LES  07/17/96  Created                                                */
/*                                                                          */
/****************************************************************************/

static T_void IFreeBuffer(T_sword16 bufferId)
{
    T_soundBuffer *p_buffer ;

    DebugRoutine("IFreeBuffer") ;
    DebugCheck(bufferId >= 0) ;
    DebugCheck(bufferId < MAX_SOUND_CHANNELS) ;
    p_buffer = G_soundBufferArray + bufferId ;
    DebugCheck(p_buffer->isAllocated == TRUE) ;

    ResourceUnlock(p_buffer->resource) ;
    ResourceUnfind(p_buffer->resource) ;
    p_buffer->resource = RESOURCE_BAD ;
    p_buffer->isAllocated = FALSE ;

    /* Take the buffer off the playing list. */
    if (p_buffer->prev != BUFFER_ID_BAD)  {
        G_soundBufferArray[p_buffer->prev].next = p_buffer->next ;
    } else {
        G_playingList = p_buffer->next ;
    }
    if (p_buffer->next != BUFFER_ID_BAD)  {
        G_soundBufferArray[p_buffer->next].prev = p_buffer->prev ;
    }

    /* Put the buffer on the free list. */
    p_buffer->next = G_firstFreeBuffer ;
    p_buffer->prev = BUFFER_ID_BAD ;
    if (G_firstFreeBuffer != BUFFER_ID_BAD)
        G_soundBufferArray[G_firstFreeBuffer].prev = bufferId ;
    G_firstFreeBuffer = bufferId ;

    G_numSoundsPlaying-- ;

    ICheckLists() ;

    DebugEnd() ;
}

/****************************************************************************/
/*  Routine:  SoundStop                                                     */
/****************************************************************************/
/*                                                                          */
/*  Description:                                                            */
/*                                                                          */
/*    SoundStop is called to force a sound to stop (particularly a looping  */
/*  sound)>                                                                 */
/*                                                                          */
/*                                                                          */
/*  Inputs:                                                                 */
/*                                                                          */
/*    T_sword16 channel            -- Channel no longer being played.       */
/*                                                                          */
/*                                                                          */
/*  Outputs:                                                                */
/*                                                                          */
/*    None.                                                                 */
/*                                                                          */
/*                                                                          */
/*  Revision History:                                                       */
/*                                                                          */
/*    Who  Date:     Comments:                                              */
/*    ---  --------  ---------                                              */
/*    LES  05/08/95  Created                                                */
/*    LES  04/29/96  Added code to put sound resource in list to unlock     */
/*    LES  07/17/96  Converted SoundDone to SoundStop and restructured      */
/*                                                                          */
/****************************************************************************/

T_void SoundStop(T_sword16 bufferId)
{
    T_soundBuffer *p_buffer ;

    DebugRoutine("SoundStop") ;

    DebugCheck(bufferId != BUFFER_ID_BAD) ;
    DebugCheck(bufferId >= 0) ;
    DebugCheck(bufferId < MAX_SOUND_CHANNELS) ;

    if (SoundIsOn())  {
        p_buffer = G_soundBufferArray + bufferId ;
        DebugCheck(p_buffer->isAllocated == TRUE) ;

        if (!sosDIGISampleDone(hDIGIDriver, p_buffer->sosHandle))
            sosDIGIStopSample(hDIGIDriver, p_buffer->sosHandle) ;
    }

    DebugEnd() ;
}

#ifdef COMPILE_OPTION_SOUND_CHECK_LIST
static T_void ICheckLists(T_void)
{
    T_soundBuffer *p_buffer ;
    T_sword16 bufferId ;

    DebugRoutine("ICheckLists") ;

    printf("Buffers free:\n") ;
    bufferId = G_firstFreeBuffer ;
    while (bufferId != BUFFER_ID_BAD)  {
        DebugCheck(bufferId != BUFFER_ID_BAD) ;
        DebugCheck(bufferId >= 0) ;
        DebugCheck(bufferId < MAX_SOUND_CHANNELS) ;
        p_buffer = G_soundBufferArray + bufferId ;

        printf("  %d (%d %d %d)\n",
            bufferId,
            p_buffer->isAllocated,
            p_buffer->prev,
            p_buffer->next) ;
        fflush(stdout) ;

        bufferId = p_buffer->next ;
    }

    printf("Buffers allocated:\n") ;
    bufferId = G_playingList ;
    while (bufferId != BUFFER_ID_BAD)  {
        DebugCheck(bufferId != BUFFER_ID_BAD) ;
        DebugCheck(bufferId >= 0) ;
        DebugCheck(bufferId < MAX_SOUND_CHANNELS) ;
        p_buffer = G_soundBufferArray + bufferId ;

        printf("  %d (%d %d %d)\n",
            bufferId,
            p_buffer->isAllocated,
            p_buffer->prev,
            p_buffer->next) ;
        fflush(stdout) ;

        bufferId = p_buffer->next ;
    }

    DebugEnd() ;
}
#endif

/* LES 07/31/96 Created */
E_Boolean SoundGetAllowFreqShift(T_void)
{
    return G_allowFreqShift ;
}

/* LES 07/31/96 Created */
T_void SoundSetAllowFreqShift(E_Boolean newAllow)
{
    G_allowFreqShift = newAllow ;
}

T_void SoundUpdateOften(T_void)
{
    static E_Boolean inHere = FALSE ;

    if (inHere != TRUE)  {
        inHere = TRUE ;
        if ((G_musicNeedsUpdate) && (G_musicFile != FILE_BAD))
            ICheckForNextMusicUpdate() ;
        inHere = FALSE ;
    }
}

static T_void ICheckForNextMusicUpdate(T_void)
{
    T_byte8 next ;
    T_byte8 now ;
    T_word16 i ;

    for (i=0; i<NUM_STREAM_BUFFERS; i++)  {
        if (G_musicNeedsUpdate)  {
            G_musicNeedsUpdate = FALSE ;

            next = G_nextFillBuffer ;
            now = G_nextMusicBuffer ;

            /* Repeat at beginning if we have reached the end. */
            if (G_musicPos >= G_musicLength)  {
                G_musicPos = 0 ;
                FileSeek(G_musicFile, 0) ;
            }

    //        if (now == 0xFF)
    //            now = NUM_STREAM_BUFFERS-1 ;

            G_musicBufferLen[next] =
                FileRead(G_musicFile,
                G_musicBuffer[next],
                SIZE_SOUND_STREAM_BUFFER) ;

            next++ ;
            if (next == NUM_STREAM_BUFFERS)
                next = 0 ;

            G_nextFillBuffer = next ;

            /* Move over a block */
            G_musicPos += SIZE_SOUND_STREAM_BUFFER ;

            if (next == now)
                G_musicNeedsUpdate = FALSE ;
            else
                G_musicNeedsUpdate = TRUE ;
        } else {
            break ;
        }
    }
}

VOID cdecl IUpdateMusicBuffer(struct _tag_sos_sample *p_sample)
{
    G_nextMusicBuffer++ ;
    if (G_nextMusicBuffer == NUM_STREAM_BUFFERS)
        G_nextMusicBuffer = 0 ;

    p_sample->pSample = G_musicBuffer[G_nextMusicBuffer] ;
    p_sample->wLength = G_musicBufferLen[G_nextMusicBuffer] ;

    G_musicNeedsUpdate = TRUE ;
}

static T_void ISoundStartStreamIO(char *filename)
{
    W32 newSong;
    T_word16 newVolume ;
    _SOS_SAMPLE *p_sample ;
    char realFilename[80] ;

	DebugRoutine("ISoundStartStreamIO") ;

    sprintf(
        realFilename,
        "%c:\\aamusic\\%s.MUS",
        ConfigGetCDROMDrive(),
        filename) ;
    if (FileExist(realFilename) == TRUE)  {
        G_musicFile = FileOpen(realFilename, FILE_MODE_READ) ;
        G_musicLength = FileGetSize(realFilename) ;

        G_musicBufferLen[0] = FileRead(G_musicFile, G_musicBuffer[0], SIZE_SOUND_STREAM_BUFFER) ;

        p_sample = &G_musicSample ;

        DebugCheck(p_sample != NULL) ;

        memset(p_sample, 0, sizeof(_SOS_SAMPLE)) ;
        p_sample->pSample = G_musicBuffer[0] ;
        p_sample->wLength = G_musicBufferLen[0] ;
        G_musicPos = G_musicBufferLen[0] ;

        p_sample->wBitsPerSample = 0x10 ;
        p_sample->wChannels = 1 ;
        p_sample->wRate = 22050 ;
        p_sample->wFormat = 0 /* signed */ ;

        p_sample->wPanPosition = _PAN_CENTER ;
        newVolume = 255 ;
        newVolume *= G_musicVolume ;
        newVolume >>= 1 ;
        p_sample->wVolume = MK_VOLUME(newVolume, newVolume) ;
        p_sample->pfnSampleProcessed = IUpdateMusicBuffer ;

        /* Force the next buffer to be filled */
        G_musicNeedsUpdate = TRUE ;
        G_nextMusicBuffer = 0 ;
        G_nextFillBuffer = 1 ;
        ICheckForNextMusicUpdate() ;

        G_musicHandle = sosDIGIStartSample(hDIGIDriver, p_sample) ;
    } else {
#ifndef NDEBUG
        printf("Could not play song %s\n", realFilename) ;
#endif
        G_musicFile = FILE_BAD ;
    }

    DebugEnd() ;
}

T_void SoundStopBackgroundMusic(T_void)
{
    DebugRoutine("SoundStopBackgroundMusic") ;

    /* Stop the original MIDI song (if playing). */
	if (G_backSong != -1)
	{
        /* stop playing the last song. */
        sosMIDIStopSong(G_backSong);
        G_backSong = -1 ;
	}

    /* Stop any digital music */
    if (G_musicFile != FILE_BAD)  {
        sosDIGIStopSample(hDIGIDriver, G_musicHandle) ;
        FileClose(G_musicFile) ;
        G_musicFile = FILE_BAD ;
    }

    DebugEnd() ;
}

/****************************************************************************/
/*  Routine:  SoundPlayByNumberWithDetails                                  */
/****************************************************************************/

T_sword16 SoundPlayByNumberWithDetails(
             T_word16 num,
             T_word16 volume,
             T_word16 frequency,
             T_word16 bits,
             E_Boolean isStereo)
{
    char buffer[20] ;
    T_sword16 bufferId = BUFFER_ID_BAD ;

    DebugRoutine("PlaySoundByNumberWithDetails") ;

    /* Don't play any sound unless the sound system was initialized. */
    if (G_soundsInit == TRUE)  {
	    sprintf(buffer, "snd#%d", (T_word32)num) ;
	    bufferId = SoundPlayByNameWithDetails(
                       buffer,
                       volume,
                       frequency,
                       bits,
                       isStereo) ;
    }

    DebugEnd() ;

    return bufferId ;
}

/****************************************************************************/
/*  Routine:  SoundPlayByNameWithDetails                                    */
/****************************************************************************/

T_sword16 SoundPlayByNameWithDetails(
              T_byte8 *filename,
              T_word16 volume,
              T_word16 frequency,
              T_word16 bits,
              E_Boolean isStereo)
{
    T_resource sound ;
    T_word32 newVolume ;
    _SOS_SAMPLE *p_sample ;
    W32 hSample;
    T_sword16 bufferId = BUFFER_ID_BAD ;
    T_soundBuffer *p_buffer ;

    DebugRoutine("PlaySoundByNameWithDetails") ;

    if (G_soundsInit == TRUE)  {
        sound = ResourceFind(G_soundsFile, filename) ;
        if (sound != RESOURCE_BAD)  {
            bufferId = IAllocateBuffer(sound) ;
            if (bufferId != BUFFER_ID_BAD)  {
                DebugCheck(bufferId < MAX_SOUND_CHANNELS) ;
                DebugCheck(bufferId >= 0) ;
                p_buffer= G_soundBufferArray + bufferId ;
                p_sample = &p_buffer->sosSample ;
                DebugCheck(p_sample != NULL) ;

                memset(p_sample, 0, sizeof(_SOS_SAMPLE)) ;
                p_sample->pSample = p_buffer->p_sample ;
                p_sample->wLength = p_buffer->size ;

                p_sample->wBitsPerSample = bits ;
                if (isStereo)
                    p_sample->wChannels = 2 ;
                else
                    p_sample->wChannels = 1 ;

                p_sample->wRate = frequency ;
                p_sample->wFormat = _PCM_UNSIGNED ;

                p_sample->wPanPosition = _PAN_CENTER ;
                newVolume = volume ;
                newVolume *= G_soundVolume ;
                newVolume >>= 1 ;
                p_sample->wVolume = MK_VOLUME(newVolume, newVolume) ;

                hSample = sosDIGIStartSample(hDIGIDriver, p_sample) ;

                /* Did we get a sound to play? */
                if (hSample != _ERR_NO_SLOTS)  {
                    /* The sound is being played.  */
                    /* Note what resource and sound */
                    /* this is. */
                    DebugCheck(hSample < MAX_SOUND_CHANNELS) ;
                    p_buffer->sosHandle = hSample ;
                    p_buffer->volume = volume ;
                    p_buffer->doneCallback = NULL ;
                } else {
                    /* No sound.  Let the buffer go. */
                    IFreeBuffer(bufferId) ;
                    bufferId = BUFFER_ID_BAD ;
                }
            }
        } else {
#ifdef COMPILE_OPTION_OUTPUT_BAD_SOUNDS
            fprintf(fileBadSounds, "sound '%s' not found\n", filename) ;  fflush(fileBadSounds) ;
            MessagePrintf("sound '%s' not found\n", filename) ;  fflush(fileBadSounds) ;
#endif
        }

    }

    DebugEnd() ;

    return bufferId ;
}

/****************************************************************************/
/*    END OF FILE:  SOUND.C                                                 */
/****************************************************************************/
